// 'use strict';

// import Node from '../tree_intersection/lib/node';
// import BinaryTree from '../tree_intersection/lib/binary-tree';
// import treeIntersection from '../tree_intersection/tree-intersection';

// const one = new Node(1);
// const two = new Node(2);
// const three = new Node(3);
// const four = new Node(4);
// const five = new Node(5);
// const six = new Node(6);
// one.left = two;
// one.right = three;
// three.left = six;
// two.left = four;
// two.right = five;
// const btOne = new BinaryTree(one);

// const sevenTwo = new Node(7);
// const twoTwo = new Node(2);
// const eightTwo = new Node(8);
// const fiveTwo = new Node(5);
// const sixTwo = new Node(6);
// sevenTwo.left = eightTwo;
// sevenTwo.right = twoTwo;
// twoTwo.left = fiveTwo;
// twoTwo.right = sixTwo;
// const btTwo = new BinaryTree(sevenTwo);

// describe('tree-intersection.test.js', () => {
//   describe('treeIntersection()', () => {
//     test('Should return an array of the values that appear in both trees.', () => {
//       expect(true).toBeTruthy();
//       // expect(treeIntersection(btOne, btTwo)).toEqual([2, 5]);
//     });
//     // test('Should throw new Error if one of the inputs is invalid.', () => {
//     //   const emptyTree1 = new BinaryTree();
//     //   const emptyTree2 = new BinaryTree();
//     //   expect(fizzBuzzTree(emptyTree)).toBeUndefined();
//     // });
//     // test('Should traverse the tree in an "in-order" fashinon.', () => {
//     //   expect(fizzBuzzTree(fbTree)).toEqual('1,Fizz,Fizz,Buzz,Buzz,2,FizzBuzz');
//     // });
//   });
// });
